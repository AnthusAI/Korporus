{"componentChunkName":"component---src-templates-docs-markdown-template-tsx","path":"/docs/guides/deployment/","result":{"pageContext":{"currentPath":"/docs/guides/deployment","sourcePath":"docs/guides/deployment.md","title":"Deployment","markdown":"# Deployment\n\nKorporus runs in three different modes. Understanding the differences is essential for debugging and deployment.\n\n## Development Mode\n\nEach app runs its own **Vite dev server** on a separate port. Port assignments are managed centrally in `@korporus/platform-config` (`packages/platform-config/src/ports.ts`).\n\n### How it works\n\n1. The shell fetches `/manifests/{app-id}.json` from its own dev server\n2. The `devManifestRewritePlugin` intercepts these requests and rewrites the `remoteEntry` field from a relative URL to `http://localhost:{port}/mf-manifest.json`\n3. The MF runtime fetches the manifest from the app's dev server, which tells it how to find the remote entry's virtual modules\n4. All module imports resolve against the app's own origin\n\n### Why the rewrite is needed\n\nIn Vite dev mode, `remoteEntry.js` is a virtual ESM module containing absolute import paths like `/node_modules/.vite/deps/react.js`. These paths only exist on the app's own Vite dev server. If the shell tried to proxy these requests, the internal imports would resolve against port 3000 (the shell) instead of port 3001 (the app).\n\nThe fix: bypass the proxy entirely. Point the MF runtime directly at the app's dev server so all imports resolve correctly.\n\n### Dev server requirements\n\nEach app's `vite.config.ts` imports its port from the central registry:\n\n```typescript\nimport { getPortEntry, getDevOrigin } from \"@korporus/platform-config\";\n\nconst APP_ID = \"hello-app\";\nconst ports = getPortEntry(APP_ID);\n\n// in defineConfig:\nserver: {\n  port: ports.dev,\n  strictPort: true,    // Fail if port taken, don't silently increment\n  cors: true,\n  origin: getDevOrigin(APP_ID),\n}\n```\n\nThe shell's `devManifestRewritePlugin` auto-discovers all app origins from the same registry:\n\n```typescript\nimport { getDevRemoteOrigins } from \"@korporus/platform-config\";\n\nconst devRemoteOrigins = getDevRemoteOrigins();\n// Returns: { \"hello-app\": \"http://localhost:3001\", \"docs-app\": \"http://localhost:3002\", ... }\n```\n\nTo add a new app, register it once in `packages/platform-config/src/ports.ts` — no manual wiring in the shell config.\n\n## Container Mode\n\nA single Docker container runs **nginx** serving all apps from one origin.\n\n### How it works\n\nThe multi-stage `Dockerfile`:\n\n1. Builds the shell and all apps with `pnpm build`\n2. Copies each app's `dist/` to nginx under `/apps/{name}/`\n3. Copies the shell's `dist/` to nginx's root `/`\n\nnginx serves everything:\n\n```\n/                        → Shell (index.html + JS)\n/apps/hello/             → Hello app (remoteEntry.js + assets)\n/apps/docs/              → Docs app (remoteEntry.js + assets)\n/manifests/              → App manifests (JSON + icons)\n/health                  → Health check endpoint\n```\n\n### No rewriting needed\n\nSince everything is on the same origin, the manifests use relative URLs:\n\n```json\n{\n  \"remoteEntry\": \"/apps/hello/remoteEntry.js\"\n}\n```\n\nThe MF runtime loads this directly. No proxy, no rewriting, no CORS.\n\n### Building the container\n\n```bash\ndocker build -t korporus-shell .\ndocker run -p 8080:8080 korporus-shell\n```\n\n## Production (AWS)\n\nIn production, the container runs on **AWS App Runner** with images stored in **ECR**.\n\n### Infrastructure\n\n- **ECR**: `korporus/shell` repository for container images\n- **App Runner**: 0.25 vCPU / 0.5 GB, port 8080, `/health` check\n- **Terraform**: Infrastructure defined in `infra/shell/`\n\n### Deployment steps\n\n```bash\n# Build and push\naws ecr get-login-password | docker login --username AWS --password-stdin <account>.dkr.ecr.<region>.amazonaws.com\ndocker build -t korporus-shell .\ndocker tag korporus-shell:latest <account>.dkr.ecr.<region>.amazonaws.com/korporus/shell:latest\ndocker push <account>.dkr.ecr.<region>.amazonaws.com/korporus/shell:latest\n\n# Deploy infrastructure\ncd infra/shell\nterraform init\nterraform apply\n```\n\nApp Runner automatically picks up new image pushes and deploys them.\n\n### Demo apps (Amplify)\n\nThe Angular and React demo apps are intended for **AWS Amplify Gen2** deployment. Each has an `amplify.yml` build spec. These are standalone hosts that load the hello app's Web Components from the App Runner container URL.\n"}},"staticQueryHashes":[],"slicesMap":{}}