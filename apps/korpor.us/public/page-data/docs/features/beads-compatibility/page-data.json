{"componentChunkName":"component---src-templates-docs-markdown-template-tsx","path":"/docs/features/beads-compatibility/","result":{"pageContext":{"currentPath":"/docs/features/beads-compatibility","sourcePath":"docs/guides/state-management.md","title":"Shared State","markdown":"# State Management\n\nKorporus apps use [Zustand](https://github.com/pmndrs/zustand) for state management. Since all three slot components (titlebar, main, settings) are loaded from the same MF remote, they share a single JavaScript context and can use the same Zustand store.\n\n## Basic Pattern\n\n```typescript\n// src/store.ts\nimport { create } from \"zustand\";\n\ninterface MyStore {\n  count: number;\n  increment: () => void;\n}\n\nexport const useMyStore = create<MyStore>((set) => ({\n  count: 0,\n  increment: () => set((s) => ({ count: s.count + 1 })),\n}));\n```\n\n## Using the Store in Slot Components\n\n```typescript\n// src/components/MyMain.tsx\nimport { useMyStore } from \"../store\";\n\nexport function MyMain() {\n  const count = useMyStore((s) => s.count);\n  const increment = useMyStore((s) => s.increment);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>+1</button>\n    </div>\n  );\n}\n```\n\nWhen `MyMain` calls `increment`, the titlebar and settings components will also re-render if they subscribe to `count`.\n\n## Why Zustand?\n\n- **No provider needed**: Unlike React Context, Zustand stores don't require a Provider wrapper. This matters because each slot is a separate React root — they don't share a React tree.\n- **Shared singleton**: Zustand is declared as a shared singleton in the MF config, so all slots use the same store instance.\n- **Simple API**: `create` + `useStore` — no boilerplate.\n\n## State Doesn't Persist\n\nBy default, Zustand state is in-memory only. When the user navigates away from the app and back, the state resets. If you need persistence, use Zustand's `persist` middleware with `localStorage`.\n"}},"staticQueryHashes":[],"slicesMap":{}}