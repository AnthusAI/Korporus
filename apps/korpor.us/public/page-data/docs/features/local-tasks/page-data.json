{"componentChunkName":"component---src-templates-docs-markdown-template-tsx","path":"/docs/features/local-tasks/","result":{"pageContext":{"currentPath":"/docs/features/local-tasks","sourcePath":"docs/architecture/web-components.md","title":"Web Component Slots","markdown":"# Web Components\n\nWeb Components are the boundary contract between the Korporus shell and federated apps. Each app registers custom HTML elements that the shell mounts into its layout slots.\n\n## The Three Slots\n\nEvery Korporus app can provide up to three slots:\n\n| Slot | Tag Name Convention | Purpose |\n|------|-------------------|---------|\n| **titlebar** | `{app-id}-titlebar` | Fixed header area (56px height) |\n| **main** | `{app-id}-main` | Primary content area (fills remaining space) |\n| **settings** | `{app-id}-settings` | Optional right sidebar (slides in from the shell chrome) |\n\n## The `registerCustomElement` Wrapper\n\nThe `@korporus/web-component-wrapper` package bridges React components to custom elements:\n\n```typescript\nimport { registerCustomElement } from \"@korporus/web-component-wrapper\";\nimport { MyMain } from \"./components/MyMain\";\n\nregisterCustomElement(\"my-app-main\", MyMain);\n```\n\nUnder the hood this:\n\n1. Defines a custom `HTMLElement` class\n2. On `connectedCallback`, creates a React root and renders your component\n3. On `disconnectedCallback`, unmounts the React root\n4. Converts kebab-case HTML attributes to camelCase props\n5. Uses light DOM by default (no Shadow DOM) for simpler styling\n\n## How the Shell Mounts Slots\n\nThe shell's `AppView` component creates custom elements imperatively:\n\n```typescript\nconst el = document.createElement(\"my-app-main\");\ncontainerRef.current.appendChild(el);\n```\n\nThis triggers the `connectedCallback` and your React component mounts. When the user navigates away, the element is removed, triggering `disconnectedCallback` and cleanup.\n\n## Shared State Across Slots\n\nSince all three slot components live in the same JavaScript context (they're loaded from the same MF remote), they can share state via Zustand:\n\n```typescript\n// store.ts â€” shared by all slots\nexport const useMyStore = create((set) => ({\n  count: 0,\n  increment: () => set((s) => ({ count: s.count + 1 })),\n}));\n```\n\nWhen one slot updates the store, all slots re-render.\n"}},"staticQueryHashes":[],"slicesMap":{}}