{"componentChunkName":"component---src-templates-docs-markdown-template-tsx","path":"/docs/features/kanban-board/","result":{"pageContext":{"currentPath":"/docs/features/kanban-board","sourcePath":"docs/architecture/module-federation.md","title":"Runtime Composition","markdown":"# Module Federation\n\nKorporus uses [Module Federation 2.0](https://module-federation.io/) (`@module-federation/vite`) to load app code at runtime without build-time coupling between the shell and apps.\n\n## Key Concepts\n\n### Host and Remote\n\n- The **shell** is the MF *host* — it consumes remote modules\n- Each **app** is an MF *remote* — it exposes modules for the host to import\n\n### Remote Entry\n\nEach app produces a `remoteEntry.js` file during build. This file is the entry point that the MF runtime loads to discover what the remote exposes.\n\n### Shared Dependencies\n\nReact, ReactDOM, and Zustand are configured as **shared singletons**. This means the shell and all apps use the same instance of these libraries at runtime — no duplicate React or conflicting state.\n\n```typescript\nshared: {\n  react: { singleton: true, requiredVersion: \"^19.0.0\" },\n  \"react-dom\": { singleton: true, requiredVersion: \"^19.0.0\" },\n  zustand: { singleton: true },\n}\n```\n\n## Dev vs Production\n\n### Development Mode\n\nIn dev mode, each app runs its own Vite dev server on a separate port. Port assignments are managed centrally in `@korporus/platform-config` (`packages/platform-config/src/ports.ts`):\n\n| Component | Port | Source |\n|-----------|------|--------|\n| Shell     | 3000 | `getDevPort(\"shell\")` |\n| Hello App | 3001 | `getDevPort(\"hello-app\")` |\n| Docs App  | 3002 | `getDevPort(\"docs-app\")` |\n\nThe shell's Vite config includes a `devManifestRewritePlugin` that rewrites the `remoteEntry` field in manifest JSON files to point at the app's `mf-manifest.json` on its own dev server origin. This is necessary because Vite dev server remoteEntry files contain absolute virtual-module paths (like `/node_modules/.vite/deps/...`) that only resolve correctly on the app's own server. The plugin auto-discovers all app origins from the port registry.\n\nEach app imports its port and origin from the registry, with `strictPort: true` to fail fast on conflicts:\n\n```typescript\nimport { getPortEntry, getDevOrigin } from \"@korporus/platform-config\";\n\nconst APP_ID = \"hello-app\";\nconst ports = getPortEntry(APP_ID);\n\nserver: {\n  port: ports.dev,\n  strictPort: true,\n  cors: true,\n  origin: getDevOrigin(APP_ID),\n}\n```\n\n### Production (Container)\n\nIn the Docker container, nginx serves everything from a single origin:\n\n- `/` — Shell\n- `/apps/hello/` — Hello app built assets\n- `/apps/docs/` — Docs app built assets\n- `/manifests/` — App manifests\n\nNo manifest rewriting is needed. The manifests use relative URLs like `/apps/hello/remoteEntry.js` which resolve naturally against the single origin.\n\n## The Bootstrap Pattern\n\nEvery Korporus app exposes exactly one module: `./bootstrap`. This module is imported as a side effect — it registers the app's Web Components and then the MF runtime is done. No return value, no function to call.\n\n```typescript\n// vite.config.ts\nexposes: {\n  \"./bootstrap\": \"./src/bootstrap.ts\",\n}\n```\n"}},"staticQueryHashes":[],"slicesMap":{}}