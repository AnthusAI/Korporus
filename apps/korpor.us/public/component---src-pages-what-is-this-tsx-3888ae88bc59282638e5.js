"use strict";(self.webpackChunk_korporus_site=self.webpackChunk_korporus_site||[]).push([[959],{5251:function(e,t,a){a.r(t);var l=a(2155),n=a(8456),s=a(6660);t.default=()=>l.createElement(n.PE,null,l.createElement(n.lq,{eyebrow:"Start Here",title:"What Is This?",subtitle:"Korporus is a federated application platform where a shell host loads independently-built app remotes at runtime.",actions:l.createElement(l.Fragment,null,l.createElement("a",{href:"/getting-started",className:"cta-button px-6 py-3 text-sm transition-all hover:brightness-95 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2"},"Getting Started"),l.createElement("a",{href:"/features",className:"text-sm font-semibold leading-6 text-foreground hover:text-selected transition-all"},"See Features ",l.createElement("span",{"aria-hidden":"true"},"->")))}),l.createElement("div",{className:"space-y-12"},l.createElement(n.wn,{title:"Why this exists",subtitle:"Modern teams need independently deployable frontend systems without brittle integration coupling."},l.createElement(s.Zp,{className:"p-8 bg-card"},l.createElement(s.Wu,{className:"p-0 space-y-4 text-muted leading-relaxed"},l.createElement("p",null,"Monolithic frontend deployment creates bottlenecks: one release pipeline, one runtime, and one failure domain."),l.createElement("p",null,"Korporus formalizes a host/remote boundary so apps can be developed, versioned, and deployed independently.")))),l.createElement(n.wn,{title:"In plain English",subtitle:"A shell that loads app modules on demand.",variant:"alt"},l.createElement(s.Zp,{className:"p-8 bg-card"},l.createElement(s.Wu,{className:"p-0 space-y-4 text-muted leading-relaxed"},l.createElement("p",null,"Each app publishes a manifest and a remote entry. The shell reads the manifest, loads bootstrap code, and mounts app Web Components into standard slots."),l.createElement("p",null,"The same remote can run inside other host applications, including the React and Angular demos in this repository.")))),l.createElement(n.wn,{title:"Contract-first integration",subtitle:"Schema validation and stable slot names keep host and remote aligned."},l.createElement(s.Zp,{className:"p-8 bg-card"},l.createElement(s.Wu,{className:"p-0 grid gap-8 md:grid-cols-2 items-center text-muted leading-relaxed"},l.createElement("div",{className:"space-y-4"},l.createElement("p",null,"The app manifest schema defines identity, remote entry URL, and slot element tags. Hosts validate before loading."),l.createElement("p",null,"That gives teams a reliable integration contract and clear failure boundaries when remotes drift.")),l.createElement("div",{className:"flex justify-center"},l.createElement("div",{className:"w-full max-w-[360px] aspect-[5/3] rounded-xl bg-card-muted border border-border/60 p-4"},l.createElement(n.Db,{type:"jira-sync",className:"w-full h-full"})))))),l.createElement(n.wn,{title:"What it's good at",subtitle:"Clear ownership, composable runtime behavior, and framework-agnostic embedding."},l.createElement(s.Zp,{className:"p-8 bg-card"},l.createElement(s.Wu,{className:"p-0 text-muted leading-relaxed"},l.createElement("ul",{className:"list-disc list-inside space-y-2"},l.createElement("li",null,"Independent app release cycles with runtime composition"),l.createElement("li",null,"Manifest-driven discovery and strict schema validation"),l.createElement("li",null,"Reusing the same app in multiple host frameworks"),l.createElement("li",null,"Preserving app-level state across titlebar/main/settings slots"),l.createElement("li",null,"Deploying static hosts separately from remote runtime infrastructure")))))))}}]);
//# sourceMappingURL=component---src-pages-what-is-this-tsx-3888ae88bc59282638e5.js.map